import Image from 'next/image'
import axios from 'axios'
import { useState, useEffect } from 'react';
import '../scss/completeReq.scss'
import { useSession } from "next-auth/react";

export default function CompleteReq({
    requests, 
    setErr, 
    dateBegin, 
    _id, 
    arrActive, 
    setArrActive, 
    workers,
    objects
}){
    const { data: session } = useSession();
    //default
    const [parts, setParts] = useState({}) // –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –∑–∞–ø—á–∞—Å—Ç–µ–π
    const [workersForObjects, setWorkersForObjects] = useState({})
    const [isLoading, setIsLoading] = useState(false);

   

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∑–∞–ø—á–∞—Å—Ç–µ–π
    async function getPartsData(partsIds) {
        try {
            const response = await axios.post('/api/parts/optionParts', { partsArr: partsIds })
            const partsMap = response.data.reduce((acc, part) => {
                acc[part._id] = part;
                return acc;
            }, {});
            return partsMap;
        } catch (error) {
            console.error('Error fetching parts data:', error)
            return {}
        }
    }

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∑–∞–ø—á–∞—Å—Ç—è—Ö –ø—Ä–∏ –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
    useEffect(() => {
        const loadPartsData = async () => {
            const partsIds = [...new Set(requests.flatMap(req => 
                req.parts.map(part => part._id)
            ))];
            const partsData = await getPartsData(partsIds);
            setParts(partsData);
        };
        
        loadPartsData();
    }, [requests]);

    useEffect(() => {
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–∞–±–æ—Ç–Ω–∏–∫–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ –ø–µ—Ä–≤—ã–º —Ä–∞–±–æ—Ç–Ω–∏–∫–æ–º –∏–∑ —Å–ø–∏—Å–∫–∞
        if (workers.length > 0) {
            const initialWorkers = requests.reduce((acc, request) => {
                acc[request._id] = workers[0].name;
                return acc;
            }, {});
            setWorkersForObjects(initialWorkers);
        }
    }, [workers, requests]);

    //functions
    async function sendCompletionNotification(dateBegin, requests) {
        try {
            const partsData = await Promise.all(requests.map(async request => {
                // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∑–∞–ø—á–∞—Å—Ç—è—Ö
                const parts = await Promise.all(request.parts.map(async part => {
                    const fullPart = await axios.post('/api/parts/optionParts', { 
                        partsArr: [part._id] 
                    });
                    return {
                        ...part,
                        name: fullPart.data[0]?.name
                    };
                }));

                // –ü–æ–ª—É—á–∞–µ–º –æ–±—ä–µ–∫—Ç –∏–∑ –ø—Ä–æ–ø—Å–æ–≤ objects –ø–æ ID
                const objectName = objects[request.obj]?.name || '–û–±—ä–µ–∫—Ç –Ω–µ —É–∫–∞–∑–∞–Ω';

                return {
                    ...request,
                    parts,
                    objectName
                };
            }));

            const message = `<b>‚ùå –ó–∞—è–≤–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞, –∑–∞–ø—á–∞—Å—Ç–∏ –∑–∞–Ω–µ—Å–µ–Ω–Ω—ã –Ω–∞ —Å–∫–ª–∞–¥ ‚ùå</b>

üë§ –í—ã–ø–æ–ª–Ω–∏–ª: ${session?.user?.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'}

üìÖ –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è: ${dateBegin}
üìÖ –î–∞—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è: ${new Date().toLocaleDateString()}

${partsData.map(request => `
üè¢ –û–±—ä–µ–∫—Ç: ${request.objectName}

üì¶ –ó–∞–ø—á–∞—Å—Ç–∏:
${request.parts.map(part => `‚Ä¢ ${part.countReq} —à—Ç. - ${part.name}`).join('\n')}`).join('\n\n')}`;

            const chatId = process.env.NEXT_PUBLIC_TELEGRAM_CHAT_ID_FORTUNACRM;

            const response = await axios.post('/api/telegram/sendNotification', { 
                message,
                chat_id: chatId,
                message_thread_id: 4
            });

            if (!response.data.success) {
                throw new Error('Failed to send notification');
            }
        } catch (error) {
            console.error('Failed to send telegram notification:', error);
            if (error.response) {
                console.error('Response data:', error.response.data);
            }
        }
    }

    async function completeReq(_id, dateBegin, requests) {
        try {
            setIsLoading(true);
            const response = await axios.post('/api/requisition/completeReq', {
                _id,
                dateBegin,
                requests,
                dateEnd: new Date().toISOString()
            });
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
            await sendCompletionNotification(dateBegin, requests);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
            setArrActive(arrActive.filter(item => item._id !== response.data));
            return response;
        } catch (error) {
            console.error('Error in completeReq:', error);
            throw new Error(error.response?.data?.error || '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–∞—è–≤–∫–∏');
        } finally {
            setIsLoading(false);
        }
    }

    

    return (
        <button 
            onClick={() => {
                completeReq(_id, dateBegin, requests)
                    .catch(error => setErr([error.message]));
            }}
            disabled={isLoading}
            className={isLoading ? 'loading' : ''}
        >
            {isLoading ? '–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ...' : '–ó–∞–≤–µ—Ä—à–∏—Ç—å'}
            <Image 
                src={'/components/complete.svg'} 
                width={20} 
                height={20} 
                alt="completeReq"
            />
        </button>
    );
}